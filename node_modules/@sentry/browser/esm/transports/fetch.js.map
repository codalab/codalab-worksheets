{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../../src/transports/fetch.ts"],"names":[],"mappings":"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","sourcesContent":["import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { Event, Response, SentryRequest, Session, TransportOptions } from '@sentry/types';\nimport { getGlobalObject, isNativeFetch, logger, supportsReferrerPolicy, SyncPromise } from '@sentry/utils';\n\nimport { BaseTransport } from './base';\n\ntype FetchImpl = typeof fetch;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction getNativeFetchImplementation(): FetchImpl {\n  /* eslint-disable @typescript-eslint/unbound-method */\n\n  // Fast path to avoid DOM I/O\n  const global = getGlobalObject<Window>();\n  if (isNativeFetch(global.fetch)) {\n    return global.fetch.bind(global);\n  }\n\n  const document = global.document;\n  let fetchImpl = global.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (typeof document?.createElement === `function`) {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      if (sandbox.contentWindow?.fetch) {\n        fetchImpl = sandbox.contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return fetchImpl.bind(global);\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n\n/** `fetch` based transport */\nexport class FetchTransport extends BaseTransport {\n  /**\n   * Fetch API reference which always points to native browser implementation.\n   */\n  private _fetch: typeof fetch;\n\n  constructor(options: TransportOptions, fetchImpl: FetchImpl = getNativeFetchImplementation()) {\n    super(options);\n    this._fetch = fetchImpl;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<Response> {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): PromiseLike<Response> {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  }\n\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n  private _sendRequest(sentryRequest: SentryRequest, originalPayload: Event | Session): PromiseLike<Response> {\n    if (this._isRateLimited(sentryRequest.type)) {\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        reason: `Transport locked till ${this._disabledUntil(sentryRequest.type)} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    const options: RequestInit = {\n      body: sentryRequest.body,\n      method: 'POST',\n      // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default\n      // https://caniuse.com/#feat=referrer-policy\n      // It doesn't. And it throw exception instead of ignoring this parameter...\n      // REF: https://github.com/getsentry/raven-js/issues/1233\n      referrerPolicy: (supportsReferrerPolicy() ? 'origin' : '') as ReferrerPolicy,\n    };\n    if (this.options.fetchParameters !== undefined) {\n      Object.assign(options, this.options.fetchParameters);\n    }\n    if (this.options.headers !== undefined) {\n      options.headers = this.options.headers;\n    }\n\n    return this._buffer.add(\n      new SyncPromise<Response>((resolve, reject) => {\n        this._fetch(sentryRequest.url, options)\n          .then(response => {\n            const headers = {\n              'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n              'retry-after': response.headers.get('Retry-After'),\n            };\n            this._handleResponse({\n              requestType: sentryRequest.type,\n              response,\n              headers,\n              resolve,\n              reject,\n            });\n          })\n          .catch(reject);\n      }),\n    );\n  }\n}\n"]}